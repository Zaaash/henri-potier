import { AppThunk, RootState } from '../../app/store'
import { PayloadAction, createAsyncThunk, createSlice } from '@reduxjs/toolkit'
import { useEffect, useState } from 'react'

import { FetchCart } from './cartAPI'

interface CartBook {
  order: number
  isbn: string
  cover: string
  title: string
  quantity: number
  price: number
}

interface offer {
  type: string
  sliceValue?: number
  value: number
}

const offers: Array<offer> = [
  { type: 'percentage', value: 4 },
  { type: 'minus', value: 15 },
  { type: 'slice', sliceValue: 100, value: 12 },
]

export interface CartState {
  value: number
  items: Array<CartBook>
  discount: number
  total: number
  status: 'idle' | 'loading' | 'failed'
}

const initialState: CartState = {
  value: 0,
  items: [],
  discount: 0,
  total: 0,
  status: 'idle',
}

const applyPromo = (soustotal: number) => {
  console.log(soustotal)
  let discount = 0
  offers.forEach((offer) => {
    switch (offer.type) {
      // pourcentage
      case 'percentage':
        const result = (soustotal * offer.value) / 100
        if (offer.value > result) discount = result
        console.log('ùùùùù', result)
        break
      // remise directe
      case 'minus':
        if (offer.value > discount) discount = offer.value
        console.log('ùùùùù', offer.value)
        break
      // remise par tranche
      case 'slice':
        if (offer.sliceValue) {
          const tranche = Math.floor(soustotal / offer.sliceValue) * offer.value
          if (tranche > discount) discount = tranche
          console.log('ùùùùù', tranche)
        }
        break
    }
  })

  return discount
}

export const fetchPromos = createAsyncThunk(
  'cart/fetchCart',
  async (codes: string) => {
    console.log('CODES :', codes)
    // const response = FetchCart('zer')
    // The value we return becomes the `fulfilled` action payload
    //console.log('sdf :', response)
    return 333 //response
  },
)
export const cartSlice = createSlice({
  name: 'cart',
  initialState,

  // Reducers e tactions associées
  reducers: {
    addToCart: (state, book: PayloadAction<CartBook>) => {
      const { order, isbn, cover, price, title } = book.payload

      // nouvel item
      if (order < 0) {
        state.items.push({
          order: state.items.length,
          isbn: isbn,
          cover: cover,
          title: title,
          quantity: 1,
          price: price,
        })
      }
      // item déjà existant : mise à jour de la quantité
      else {
        state.items[order].quantity += 1
      }
      state.value += price
      const discount = applyPromo(state.value)
      state.discount = discount
      state.total = state.value - discount
    },
    delCart: (state, order: PayloadAction<number>) => {
      state.value -=
        state.items[order.payload].price * state.items[order.payload].quantity
      const discount = applyPromo(state.value)
      state.discount = discount
      state.total = state.value - discount
    },
  },

  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(fetchPromos.pending, (state) => {
        state.status = 'loading'
        console.log('loading2....................')
      })
      .addCase(fetchPromos.fulfilled, (state, action) => {
        state.status = 'idle'
        console.log('idle2....................')
        // state.value += action.payload
        console.log('state2....................', state.value)
      })
  },
})

export const { addToCart, delCart } = cartSlice.actions

// Sélecteurs
export const selectCart = (state: RootState) => state.cart.value
export const selectItems = (state: RootState) => state.cart.items
export const selectDiscount = (state: RootState) => state.cart.discount
export const selectTotal = (state: RootState) => state.cart.total

// Ajout d'un livre en vérifiant qu'il n'est pas déjà dans le panier
// Dans ce cas, on récupère l'emplacement du livre en question dans la liste
export const insertBook = (book: CartBook): AppThunk => (
  dispatch,
  getState,
) => {
  const items = selectItems(getState())
  const newBook = { ...book }

  let placement = -1
  items.forEach((item, key) => {
    if (book.isbn === item.isbn) placement = key
  })
  newBook.order = placement
  dispatch(addToCart(newBook))
}

export default cartSlice.reducer
